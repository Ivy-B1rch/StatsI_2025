x <- y
y <- newnum
}
num_vec[i] <- fibby
}
fib <- num_vec
return(fib)
}
fibonacci(10)
fibonacci(c(1, 2, 3, 4, 5))
fibonacci(c(3, 9, 12))
fibonacci <- function(num_vec){
#stop if invalid entry
stopifnot(is.numeric(num_vec))
#make empty vector to fill up
#for each number in the vector
for (i in 1:length(num_vec)){
x <- 0
y <- 1
newnum <- 0
for (z in 1:num_vec[i]){
fibby <- x #if im only running it once, i want a zero, so i put this here
newnum <- x + y
x <- y
y <- newnum
}
num_vec[i] <- fibby #subsetting an existing vector seems the best way to handle the returns
}
fib <- num_vec
return(fib)
}
fibonacci(10)
fibonacci(c(1, 2, 3, 4, 5))
fibonacci(c(3, 9, 12))
set.seed(2025)
n <- 200
m <- 1000
mat <- matrix(rnorm(m * n, mean = 20, sd = 3), nrow = 200)
# For simplicity, let's assume that assignment to
# control and experimental groups is always the same.
grp <- rep(0:1, times = 100)
str(mat)
str(mat[[1]])
str(mat[[2]])
str(mat[1])
str(mat[1][1])
str(mat[1][2])
str(mat[1,2])
str(mat[1,1])
str(mat[1,100])
str(mat[1])
str(mat[,1])
str(mat)
#odd rows in the matrix
#this is goofy, but it can scale if the matrix gets more rows added later
l$M[(l$M[1:10] %% 2) ==1,]
str(mat[1,])
str(mat[,1])
str(mat)
mat([1:10])
mat[1:10]
mat[1:10,1:10]
str(mat[,1])
experiment <- function(mat,grp)
#set up our starting variable
tstats <- rep(NA,100)
for (i in grp){
t.test(mat[,i])
}
experiment(mat,grp)
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in grp){
t.test(mat[,i])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in grp){
t.test(mat[,i])
}
str(mat[,1])
t.test(mat)
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in x){
t.test(y[i])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in x){
t.test(y[200,i])
}
str(grp)
deshawn <− rnorm ( n=806 , mean = 55.3 sd = 14.4 )
deshawn <− rnorm( n=806 , mean = 55.3 sd = 14.4 )
orm(n=806, mean = 55.3, sd = 14.4 )
deshawn <- rnorm(n=806, mean = 55.3, sd = 14.4 )
str(deshawn)
str(mat[1,])
str(mat[,1])
str(mat[1,])
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in x){
tstats[i] <- t.test(y[i,],[,i])
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in x){
t.test(y[i,],[,i])
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in x){
tstats[i] <- t.test(y[i,],[,i])
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in x){
tstats[i] <- t.test(y[i,],y[,i])
}
str(mat[1,])
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in x){
tstats[i] <- t.test(y[i,])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(x){
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(x)){
tstats[i] <- t.test(y[i,],y[,i])
}
str(mat[[1,]])
str(mat[[1]])
str(mat[1,])
str(mat[,1])
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(x)){
tstats[i] <- t.test(y[,i])
}
str(y[,i])
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(x)){
str(y[,i])
tstats[i] <- t.test(y[,i])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(x)){
str(y[,i])
#tstats[i] <- t.test(y[,i])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(y)){
tstats[i] <- t.test(x[,i])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(y)){
x[,i]
tstats[i] <- t.test(x[,i])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(y)){
x[,i]
#tstats[i] <- t.test(x[,i])
}
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(y)){
str(x)
#tstats[i] <- t.test(x[,i])
}
return(tstats)
experiment <- function(x,y)
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(y)){
str(x)
#tstats[i] <- t.test(x[,i])
}
#return(tstats)
experiment(mat,grp)
set.seed(2025)
n <- 200
m <- 1000
mat <- matrix(rnorm(m * n, mean = 20, sd = 3), nrow = 200)
# For simplicity, let's assume that assignment to
# control and experimental groups is always the same.
grp <- rep(0:1, times = 100)
str(mat)
str(mat[1,])
str(mat[,1])
str(grp)
experiment <- function(newmat,newgrp) #im naming the variables this funky thing so its a reusable function
#set up our starting variable
tstats <- rep(NA,100)
for (i in 1:length(newmat)){
tstats[i] <- t.test(newgrp[,i])
}
experiment <- function(mat,grp)
#set up our starting vector
tstats <- rep(NA,100)
for (i in 1:length(newmat)){
tstats[i] <- t.test(newgrp[,i])
}
(grp)
experiment <- function(mat,grp)
#set up our starting vector
tstats <- rep(NA,times = length(grp))
for (i in 1:length(grp)){
tstats[i] <- t.test(mat[,i])
}
#set up our starting vector
tstats <- rep(NA,times = length(grp))
return(tstats)
experiment <- function(mat,grp)
#set up our starting vector
tstats <- rep(NA,times = length(grp))
for (i in 1:length(grp)){
tstats[i] <- t.test(mat[,i])
}
return(tstats)
experiment <- function(mat,grp){
#set up our starting vector
tstats <- rep(NA,times = length(grp))
for (i in 1:length(grp)){
tstats[i] <- t.test(mat[,i])
}
return(tstats)
}
experiment(mat,grp)
warnings()
t.test(mat[,1])
tstats <- rep(NA,times = length(grp))
str(tstats)
experiment <- function(mat,grp){
#set up our starting vector
tstats <- rep(NA,times = length(grp))
str(tstats)
for (i in 1:length(grp)){
tstats[i] <- t.test(mat[,i])$statistic
}
return(tstats)
}
experiment(mat,grp)
set.seed(2025)
dfs <- lapply(
1:10,
function(n) data.frame(x = letters[sample(1:26,20,TRUE)], y = sample(1:26,20,TRUE))
)
str(dfs)
set.seed(2025)
dfs <- lapply(
1:10,
function(n) data.frame(x = letters[sample(1:26,20,TRUE)], y = sample(1:26,20,TRUE))
)
str(dfs)
for (i in 1:length(defs)){
if (i != 10){
rbind(dfs[i],dfs[i+1])
}
}
set.seed(2025)
dfs <- lapply(
1:10,
function(n) data.frame(x = letters[sample(1:26,20,TRUE)], y = sample(1:26,20,TRUE))
)
str(dfs)
for (i in 1:length(dfs)){
if (i != 10){
rbind(dfs[i],dfs[i+1])
}
}
str(dfs)
set.seed(2025)
dfs <- lapply(
1:10,
function(n) data.frame(x = letters[sample(1:26,20,TRUE)], y = sample(1:26,20,TRUE))
)
str(dfs)
df <- list()
for (i in 1:length(dfs)){
if (i != 10){
df <- rbind(dfs[i],dfs[i+1])
}
}
df
df
df <- list()
df
for (i in 1:length(dfs)){
if (i != 10){
df <- rbind(dfs[i],dfs[i+1])
df
}
}
set.seed(2025)
dfs <- lapply(
1:10,
function(n) data.frame(x = letters[sample(1:26,20,TRUE)], y = sample(1:26,20,TRUE))
)
df <- list()
df
for (i in 1:length(dfs)){
if (i != 10){
df <- rbind(dfs[i],dfs[i+1])
df
}
}
set.seed(2025)
dfs <- lapply(
1:10,
function(n) data.frame(x = letters[sample(1:26,20,TRUE)], y = sample(1:26,20,TRUE))
)
df <- list()
df
for (i in 1:length(dfs)){
if (i != 10){
df <- rbind(dfs[i],dfs[i+1])
str(df)
}
}
df <- dfs[1]
for (i in 2:length(dfs)){
if (i != 10){
df <- rbind(dfs[i],dfs[i+1])
str(df)
}
}
df
df <- dfs[1]
df
for (i in 2:length(dfs)){
print(i)
if (i != 10){
str(df)
df <- rbind(dfs[i],dfs[i+1])
}
}
df <- dfs[[1]]
for (i in 2:length(dfs)){
print(i)
if (i != 10){
str(df)
df <- rbind(dfs[[i]],dfs[[i+1]])
}
}
df
df
set.seed(2025)
dfs <- lapply(
1:10,
function(n) data.frame(x = letters[sample(1:26,20,TRUE)], y = sample(1:26,20,TRUE))
)
df <- dfs[[1]]
for (i in 2:length(dfs)){
print(i)
if (i != 10){
str(df)
df <- rbind(dfs[[i]],dfs[[i+1]])
}
}
df
str(df)
df <- dfs[[1]]
for (i in 2:length(dfs)){
print(i)
if (i != 10){
df <- rbind(df,dfs[[i]])
}
}
str(df)
df <- dfs[[1]]
for (i in 2:length(dfs)){
df <- rbind(df,dfs[[i]])
}
str(df)
df
inc.sub <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsI_2025/main/datasets/incumbents_subset.csv")
#part 1, run a regression
VoteDifReg <- lm(voteshare~difflog, inc.sub)
#part 2 make a scatterplot
ggplot(inc.sub, aes(x= difflog, y = voteshare)) +
geom_point() +
geom_smooth(method='lm')
#####################
# load libraries
# set wd
# clear global .envir
#####################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
library(ggplot2)
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
# here is where you load any necessary packages
# ex: stringr
# lapply(c("stringr"),  pkgTest)
# set wd for current folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# read in data
inc.sub <- read.csv("https://raw.githubusercontent.com/ASDS-TCD/StatsI_2025/main/datasets/incumbents_subset.csv")
#part 1, run a regression
VoteDifReg <- lm(voteshare~difflog, inc.sub)
#part 2 make a scatterplot
ggplot(inc.sub, aes(x= difflog, y = voteshare)) +
geom_point() +
geom_smooth(method='lm')
#Question 2
PresVoteReg <-lm(presvote~difflog, inc.sub)
#scatterplot
ggplot(inc.sub, aes(x= presvote, y = difflog)) +
geom_point() +
geom_smooth(method='lm')
VotePresReg <- lm(voteshare~presvote, inc.sub)
#scatterplot
ggplot(inc.sub, aes(x= presvote, y = voteshare)) +
geom_point() +
geom_smooth(method='lm')
#part 1, run a regression
VoteDifReg <- lm(voteshare~difflog, inc.sub)
#part 2 make a scatterplot
ggplot(inc.sub, aes(x= difflog, y = voteshare)) +
geom_point() +
geom_smooth(method='lm')
#part 3 get the residuals
VoteDifResid <- VoteDifReg$residuals
#prediction equation
#Question 2
PresVoteReg <-lm(presvote~difflog, inc.sub)
#scatterplot
ggplot(inc.sub, aes(x= presvote, y = difflog)) +
geom_point() +
geom_smooth(method='lm')
PresVoteResid <- PresVoteReg$residuals
VotePresReg <- lm(voteshare~presvote, inc.sub)
#scatterplot
ggplot(inc.sub, aes(x= presvote, y = voteshare)) +
geom_point() +
geom_smooth(method='lm')
VotePresResid <- VotePresReg$residuals
#part 4
lm(VoteDifResid~PresVoteResid)
ggplot(inc.sub, aes(x= PresVoteResid, y = VoteDifResid)) +
geom_point() +
geom_smooth(method='lm')
#part 4
lm(VoteDifResid~PresVoteResid)
ggplot(inc.sub, aes(x= PresVoteResid, y = VoteDifResid)) +
geom_point() +
geom_smooth(method='lm')
str(VoteDifReg)
VoteDifReg
PresVoteReg <-lm(presvote~difflog, inc.sub)
PresVoteReg
PresVoteReg <-lm(presvote~difflog, inc.sub)
PresVoteReg
VotePresReg <- lm(voteshare~presvote, inc.sub)
VotePresReg
#part 4
lm(VoteDifResid~PresVoteResid)
#part 4
lm(VoteDifResid~PresVoteResid)
VoteDifReg
summary(VoteDifReg)
summary(PresVoteReg)
summary(VotePresReg)
#part 4
summary(lm(VoteDifResid~PresVoteResid))
summary(lm(voteshare~difflog+presvote,inc.sub))
#part 5
lm(voteshare~difflog+presvote,inc.sub)
lm(VoteDifResid~PresVoteResid)
summary(lm(VoteDifResid~PresVoteResid))
#part 5
summary(lm(voteshare~difflog+presvote,inc.sub))
